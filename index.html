<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Principle of Software Engineer</title>
    <link rel="stylesheet" href="css/styles.css" />
  </head>
  <body>
    <h1>Principle of Software Engineering</h1>
    <hr />

    <h2>General Principles :-</h2>

    <!--  &emsp; it is give a four space to our HMTL code  -->
    <p>
      The dictionary defines the word principle as “an important underlying law
      or assumption required in a system of thought.” Throughout this book I’ll
      discuss principles at many different levels of abstraction. Some focus on
      software engineering as a whole, others consider a specific generic
      framework activity (e.g.<strong>communication</strong>), and still others
      focus on software engineering actions (e.g., architectural design) or
      technical tasks (e.g., write a usage scenario). Regardless of their level
      of focus, principles help you establish a mind-set for solid software
      engineering practice. They are important for that reason. David Hooker
      [Hoo96] has proposed seven principles that focus on software engineering
      practice as a whole. They are reproduced in the following paragraphs
    </p>
    <hr />
    <h2>The First Principle:<em> The Reason It All Exists</em>:-</h2>
    <p>
      A software system exists for one reason: to provide value to its users.
      All decisions should be made with this in mind. Before specifying a system
      requirement, before noting a piece of system functionality, before
      determining the hardware platforms or development processes, ask yourself
      questions such as: “Does this add real value to the system?” If the answer
      is “no,” don’t do it. All other principles support this one.
    </p>
    <hr />
    <h2>The Second Principle: <em>KISS (Keep It Simple, Stupid!)</em>:-</h2>
    <p>
      Software design is not a haphazard process. There are many factors to
      consider in any design effort.
      <em>All design should be as simple as possible, but no simpler.</em> This
      facilitates having a more easily understood and easily maintained system.
      This is not to say that features, even internal features, should be
      discarded in the name of simplicity. Indeed, the more elegant designs are
      usually the more simple ones. Simple also does not mean “quick and dirty.”
      In fact, it often takes a lot of thought and work over multiple iterations
      to simplify. The payoff is software that is more maintainable and less
      error-prone.
    </p>
    <hr />
    <h2>The Third Principle: <em> Maintain the Vision</em>:-</h2>
    <p>
      <em>A clear vision is essential to the success of a software project.</em
      >Without one, a project almost unfailingly ends up being “of two [or more]
      minds” about itself. Without conceptual integrity, a system threatens to
      become a patchwork of incompatible designs, held together by the wrong
      kind of screws. . . . Compromising the architectural vision of a software
      system weakens and will eventually break even the well-designed systems.
      Having an empowered architect who can hold the vision and enforce
      compliance helps ensure a very successful software project
    </p>
    <hr />
    <h2>
      The Fourth Principle: <em> What You Produce, Others Will Consume</em>:-
    </h2>
    <p>
      Seldom is an industrial-strength software system constructed and used in a
      vacuum. In some way or other, someone else will use, maintain, document,
      or otherwise depend on being able to understand your system. So,
      <em
        >always specify, design, and implement knowing someone else will have to
        understand what you are doing.</em
      >The audience for any product of software development is potentially
      large. Specify with an eye to the users. Design, keeping the implementers
      in mind. Code with concern for those that must maintain and extend the
      system. Someone may have to debug the code you write, and that makes them
      a user of your code. Making their job easier adds value to the system
    </p>
    <hr />
    <h2>The Fifth Principle:<em>Be Open to the Future</em>:-</h2>
    <p>
      A system with a long lifetime has more value. In today’s computing
      environments, where specifications change on a moment’s notice and
      hardware platforms are obsolete just a few months old, software lifetimes
      are typically measured in months instead of years. However, true
      “industrial-strength” software systems must endure far longer. To do this
      successfully, these systems must be ready to adapt to these and other
      changes. Systems that do this successfully are those that have been
      designed this way from the start.
      <em>Never design yourself into a corner.</em>Always ask “what if,” and
      prepare for all possible answers by creating systems that solve the
      general problem, not just the specific one.14 This could very possibly
      lead to the reuse of an entire system
    </p>
    <hr />
    <h2>The Sixth Principle: <em> Plan Ahead for Reuse</em>:-</h2>
    <p>
      Reuse saves time and effort.15Achieving a high level of reuse is arguably
      the hardest goal to accomplish in developing a software system. The reuse
      of code and designs has been proclaimed as a major benefit of using
      object-oriented technologies. However, the return on this investment is
      not automatic. To leverage the reuse possibilities that object-oriented
      [or conventional] programming provides requires forethought and planning.
      There are many techniques to realize reuse at every level of the system
      development process. . . .
      <em
        >Planning ahead for reuse reduces the cost and increases the value of
        both the reusable components and the systems into which they are
        incorporated</em
      >
    </p>
    <hr />
    <h2>The Seventh principle: <em>Think!</em>:-</h2>
    <p>
      This last principle is probably the most overlooked.
      <em
        >Placing clear, complete thought before action almost always produces
        better results.</em
      >. When you think about something, you are more likely to do it right. You
      also gain knowledge about how to do it right again. If you do think about
      something and still do it wrong, it becomes a valuable experience. A side
      effect of thinking is learning to recognize when you don’t know something,
      at which point you can research the answer. When clear thought has gone
      into a system, value comes out. Applying the first six principles requires
      intense thought, for which the potential rewards are enormous. If every
      software engineer and every software team simply followed Hooker’s seven
      principles, many of the difficulties we experience in building complex
      computerbased systems would be eliminated.
    </p>
    <hr />
  </body>
</html>
